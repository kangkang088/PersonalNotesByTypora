# Unity常见面试题-群友分享

## Unity面试部分

### 1:Unity脚本的生命周期？

​	答:Awake——>OnEnable——>Start——>FixedUpdate——>Update——>LateUpdate——>OnGui——>OnDisable——>OnDestroy

### 2:Unity3D支持的作为脚本的语言名称？

​	答:Unity的脚本语言基于Mono在.Net平台上运行，主要有C#和JavaScript(不再使用)

### 3:.Net与Mono的关系?

​	答:Mono是.Net的一个跨平台开源工具，类似Java的虚拟机，Java本身不能跨平台，但是通过虚拟机就可以实现跨平台功能。.Net只能在Windows下运行，而Mono可以实现跨平台编译运行

### 4:移动相机动作在哪个函数里？为什么在这个函数里

​	答:LateUpdate,因为该函数会在Update之后执行，也就是说相机移动时游戏中的物理计算已经完成了，可以有效地进行物理同步和防止相机抖动。另外Unity中的输入系统通常是在Update中处理的，在LateUpdate中移动相机可以使得相机的移动是基于最新的数据状态进行的，更加的准确和及时。

### 5.物理计算一般在哪个函数里？为什么在这个函数里

​	答:FixedUpdate中，为了确保物理模拟的稳定性，为了防止帧率变化导致的物理模拟不一致问题。

### 6:简述四元数Quaternion的作用，四元数对欧拉角的优点？

​	答:四元数表示一个旋转，它解决了欧拉角的万向节死锁的问题以及同一角度表达不唯一的问题。

### 7:CharacterContorller和Rigidbody的区别?

​	答:Rigidbody主要是通过控制速度来实现移动，而CharacterContorller是通过速度和模拟碰撞实现移动，可以很方便的在各种复杂地形中实现角色移动功能，但是Rigidbody具有接近真实的物理效果，而CharacterContorller可以说是受限制的。

### 8:简述进程、线程、协程的概念

​	答:(1)进程是操作系统进行资源分配和调度的基本单位，进程占据独立的内存，不同的进程之间可以相互通信。

​		(2)线程又叫做轻量级进程从属于进程，是CPU调度的最小单位，一个进程至少包含一个主线程，也可以有多个子线程，但是相比于进程来说不够稳定，因为线程间通讯主要通过共享内存。

​		(3)协程又叫做轻量级线程，由用户完全控制。一个线程可以有多个协程，完全由程序控制，协程可以帮助我们实现异步方法，开销更小但是失去了线程调用多CPU的能力。

​		注意:线程和协程都是共享堆但不共享栈

### 9:简述协程的底层原理

​	答:协程的底层原理主要基于迭代器实现的。在C#中迭代器需要实现IEnumerator接口，包括Current、MoveNext和Reset方法。为了简化迭代器的编写，C#提供了yield关键字作为语法糖。yield允许协程在执行到某个点时挂起自身，并将控制权返回给协程调度器。当调度器决定恢复该协程时，协程会从挂起的位置继续执行。yield语句在每次执行后会检查MoveNext方法的条件，当条件满足时，协程调度器才会继续执行代码。协程内部可以包含多个yield语句，这使得协程能够根据需要灵活地在不同的状态之间切换。这种机制类似于状态模式，其中每个yield语句都代表一个状态转换点。

### 10:简述Invoke与协程的区别

​	答:Invoke是Unity中的一种委托机制，执行没有被挂起。协程的本质是迭代器，在需要挂起当前执行时使用，开销不大。

### 11:正在运行的脚本，隐藏物体与禁止脚本导致触发OnDisable时，Invoke与Coroutine是否会正常执行？为什么？

​	答:禁止脚本之后，Invoke和Coroutine都会继续执行，而隐藏物体之后只有Invoke会正常执行。因为停止脚本之后游戏对象依然可以通过反射获取到协程迭代器对象继续执行。而隐藏物体之后相当于该游戏物体的生命周期也停止了，协程自然也会停止。

### 12:Unity3D的物理引擎中，有几种施加力的方式？分别是什么？

​	答:有两种，分别是AddForce和AddForceAtPosition

### 13:Image和RawImage的区别

​	答:(1)Image适用于需要进行变换的场景，例如平铺裁剪旋转之类的，而RawImage则更适用于背景图等单独展示的地方。

(2)Image比RawImage更消耗性能

(3)Image只能使用Sprite属性的图片，但是RawImage什么样的都能使用

### 14:在场景中放置多个Camera并同时处于活动状态会发生什么?

​	答:受到Camrea覆盖的场景物体都会同时实施绘制，MainCamrea视角里会有多个Camrea的渲染合集，可以通过深度和Layer来调整不同摄像机的显示内容

### 15:MipMap是什么，作用？

​	答:是一种纹理映射的技术，导入纹理时如果启用了MipMap那么引擎就会自动生成像素从大到小的几张图，然后当纹理在场景中缩小时，Unity会自动选择合适的MipMap级别来显示，有助于提高渲染性能。

### 16:简述对象池，游戏开发中哪些东西适合使用对象池?

​	答:对象池是一种管理和复用对象的优化技术，用于减少频繁创建和销毁对象所带来的开销。对象池通过预先创建对象并储存起来，当需要对象时从池中获取，使用完毕后再放入池中，从而显著提高程序的性能和效率。

### 17:Unity3D是否支持多线程程序?如果支持的话需要注意什么?

​	答:支持，要注意unity仅能从主线程访问Unity3D的组件和对象等内容，但是要通过子线程来控制Unity的对象的话我们可以使用一个中间容器来储存该对象需要使用到的参数，最后再由主线程通过容器中的数值对游戏物体的移动等功能进行操纵。但是要确保一个线程只能在特定时间内访问特定对象，不然可能会出现问题，因此我们可以使用C#中的lock关键字，来尽可能的避免这种情况的发生。

### 18:点乘，叉乘，归一化的意义?

​	答:点乘描述了两个向量的相似程度，我们可以得到两个向量之间的夹角；叉乘得到的向量垂直于原来的两个向量；标准化向量只关心方向而不关心大小

### 19:请简述如何在不同分辨率下保持UI的一致性

​	答:CanvasScaler中的第二种模式就是根据屏幕分辨率来进行缩放适配的，还可以在Match中调整宽高来设置匹配关系，也可以在RectTransform的center中使用shift和alt键对UI对象的位置，中心点，锚点进行配置

### 20:什么叫动态合批?和静态合批有什么区别?

​	答:动态合批和静态合批是优化图形渲染的技术，动态合批是在游戏进行时Unity帮我们做的，只需要它们共用相同材质。而静态合批是在构建时就已经处理好了，Unity再编译时会将它们合批到一个DrawCall中，需要我们在inspactor面板勾选上static选项，而且经过静态合批后的物体都不能移动了，缺点是会占用额外的内存。

### 21:什么是LightMap?

​	答:光照贴图，在建模软件中提前将光照信息输出到贴图上，最后通过引擎贴到场景上，这样物体就有了光照的感觉，可以降低渲染的压力

### 22:Unity3Dshader分哪几种?

​	答:表面着色器，片元着色器

### 23:GPU的工作原理

答:应用阶段——>几何阶段——>光栅化阶段，每一个阶段都会对数据进行处理，最终目的就是让我们看见最终的图像

### 24:什么是渲染管线

​	答:渲染管线也叫做渲染流水线，指在显示器上为了显示出图像而经过的一系列必要操作。

### 25:Camera组件的Depthonly是什么意思？有什么用处？

​	答:仅深度，该模式用于涉及多摄像机的场景，之渲染可见对象的深度信息，而将背景完全保持透明

### 26:在编辑场景时将GameObject设置为Static有什么作用?

​	答:将会剔除或禁用网格

### 27:将图片的TextureType选项分别设置为Textrue和Sprite有什么区别?

​	答:Sprite作为UI精灵使用，Textrue作用模型贴图使用	

### 28:实时点光源的优缺点是什么?

​	答:真实的光照和阴影，可以移动；缺点是性能开销较大

### 29:有限状态机和行为树?

​	答:有限状态机——指在不同阶段会呈现出不同的运行状态的系统，这些状态是有限，在某一时刻一定会处于其中的一个状态之中。

​		行为树——

### 30:Text和TMPText的区别和优缺点？

​	答:渲染方式方面——Text是像素渲染，放大之后就会模糊；TMPText是网格渲染。

​	应用场景方面——TMPText更适用于不会变动的文字，因为渲染方式的原因，更换文字的消耗会比Text大

### 31:Animation和Animator的区别?

​	答:Animation控制一个动画的播放，Animator控制多个动画之间的相互切换

### 32:Unity常用的资源路径有哪些?

​	答:Application.dataPathApplication.streamingAssetsPathApplication.persistentData

### 33:射线检测碰撞物的原理是?

​	答:射线检测是从一个点向另一个方向发射的一条射线，会记录在发射轨迹中于是否与其他物体发生碰撞或者这些物体的碰撞信息

### 34:UGUI合批的一些问题

​	答:字体和UI不能合批

### 35:Avator的作用

​	答:为用户提供的模型骨架和Unity的骨架结构进行适配，是一种骨架映射关系，有人形，非人形，类人形

### 36:动画分层的作用是什么?

​	答:身体部位动画分层，比如只想动头，但是身体不想动时，可以方便处理动画区分

### 37:编译原理——C#ILIL2CPPNative

​	答:游戏发布时Unity会把C#代码通过C#编译器转换为IL中间代码，然后再通过Mono虚拟机将这些中间代码转化为Native原生代码，能让我们在各个硬件上执行，而IL2CPP的意思就是ILtoCplusplus，通过这个方式可以把IL中间代码转换成C++代码，能让游戏运行时效率更高。

### 38:Unity的垃圾回收机制

​	答:标记清除算法:每次GC时会检查堆内存上的每个储存变量，对每个变量会检查其是否处于激活状态，如果变量的引用不再处于激活状态，则被标记为可回收，被标记的变量会被移除，其所占的内存会被回收到堆内存上，缺点是会产生内存碎片

​		复制算法:将内存分为两个区域，每次只使用其中一块区域，当一个区域满了，会将所有活动的对象复制到另一个区域，然后清除原来的区域，这不会产生内存碎片，但是需要更多的内存

​		分代算法:唐老狮

## C#面试部分

### 1:Dictionary底层原理

​	答:字典底层主要通过哈希函数和拉链法

​		哈希函数:将键转化为哈希值，用于确定哈希桶的位置

​		哈希桶:为每个hashCode建立一个桶，桶里面放着一个叫Entry的结构体

​		拉链法:将产生冲突的元素建立一个单链表，然后将头指针地址存储到对应的桶的位置，这样就可以通过定位哈希桶然后遍历单链表的方式来查找元素

### 2:链表的底层原理

​	答:节点——链表的基本单位是节点，每个节点包含数据部分和引用部分，数据部分储存的是具体的值，引用部分储存的是下一个节点的地址。

​		头节点——链表的第一个节点就是头节点

​		尾节点——链表的最后一个节点叫做尾节点，一般指向空

​		添加节点——

​		删除节点——从链表中找到该节点后更改其前一个节点的引用，使其指向被删除节点的下一个节点，然后被删除的节点要置空，避免内存泄漏

​		查找节点——链表的查找需要从头节点一节一节往下遍历

​		双链表——它的节点除了data和next外，还需要一个指向前置节点的指针

​		环形链表——最后一个链表的next指向链表的头部地址

​		如何判断一个链表有没有环——双指针算法，设置两个指针，一个快指针每次移动两步，一个慢指针每次移动一步，如果链表有环，那么两个指针最终会在某个节点相遇，如果没有环，那么快指针会最先达到尾部

### 3:结构体和类的区别

​	（1）class是引用类型，struct是值类型

（2）在托管堆上创建类的实例，在栈上创建struct实例

（3）class实例的赋值，赋的是引用地址，struct实例的赋值，赋的是值

（4）class作为参数类型传递，传递的是引用地址，struct作为参数类型传递，传递的是值

（5）class没有默认无参构造函数，struct有默认无参构造函数

（6）class支持继承，struct不支持继承

（7）class偏向于"面向对象",用于复杂、大型数据，struct偏向于"简单值"，比如小于16字节，结构简单

（8）class的成员很容易赋初值，很难给struct类型成员赋初值

（9）class的实例只能通过newSomeClass()来创建，struct类型的实例既可以通过newSomeStruct()来创建，也可以通过SomeStructmyStruct;来创建

### 4:密封类和普通类的区别

​	答:密封类不能被继承，密封方法不能被重写

### 5:抽象类和接口的区别

1:抽象类可以有构造函数；接口不能

2:抽象类只能被单一继承；接口可以继承多个

3:抽象类中可以有成员变量；接口不能

4:抽象类中可以声明成员方法，虚方法，抽象方法，静态方法；接口中只能申明为实现的抽象方法

5:抽象类可以使用访问修饰符；接口中不建议写，默认public

### 6:重载和重写的区别

​	1:所处位置不同，重载在同类中，重写是在子类中

​	2:定义方式不同，重载方法名相同参数列表不同，重写方法名和参数列表都相同

​	3:调用方式不同，重载使用相同对象以不同参数调用，重写用不同对象以相同参数调用

​	4:多态时机不同,重载是编译时多态，重写是运行时多态

### 7:链表和数组的区别

​	答:数组是顺序存储，占用一块连续的内存，大小固定，扩容成本大；链表是链式存储，是非连续的，不存在大小限制，天然支持扩容

### 8:List的底层实现

​	答:动态的泛型可扩容数组

### 9:单例模式

​	答:构造函数私有，外部无法直接创建

### 10:观察者模式

​	答:通过委托实现一对多的订阅关系

### 11:工厂模式

​	答:根据不同的条件需求，构建不同的实例，而不需要外部来操心这个过程

### 12:策略模式

​	答:根据不同的条件需求，构建不同的实例，并且在策略模式内封装具体的自定义行为接口

### 13:命令模式

​	答:有执行队列的需求，且支持撤销需求

### 14:状态模式

​	答:根据不同的状态实现不同的行为

### 15:装箱拆箱

​	答:装箱就是将值类型转换为引用类型拆箱就是将引用类型转换为值类型

### 16:垃圾回收机制

​	答:分代算法

### 17:堆和栈的区别

​	答:栈由操作系统自动分配，堆由程序员自己分配释放；栈使用一级缓存，堆使用二级缓存；栈先进后出，堆先进先出

### 18:静态构造函数

​	答:一个类只能用一个静态构造函数，无参构造函数可以与静态构造函数并存，最多只运行一次，静态构造函数不可以被继承

### 19:左值右值

​	答:inta=1;a是左值b是右值

### 20:值类型和引用类型

​	答:

### 21:序列化和反序列化

​	答:序列化是把对象转换成字节序列的过程反序列化是把字节序列恢复成对象的过程

## LUA面试部分

### 1.:闭包

​	答:一个函数可以嵌套在另一个函数中，内部函数可以访问外部函数的局部变量，改变临时变量的生命周期

### 2:Ipairs遍历

​	答:从1开始往后遍历，小于等于0的值得不到，只能找到连续索引的键，如果中间断续了，也无法找到后面的内容

### 3:Pairs遍历

​	答:非常强大，可以按照顺序遍历所有的键和值

### 4:.和:调用的区别

​	答:冒号调用方法，会默认把调用者作为第一个参数传入方法中，隐式传递自身

### 5:Self

​	答:冒号声明时，作为第一个方法的默认参数，也就是冒号调用者自身

### 6:脚本卸载

​	答:package.loaded[“脚本名”]=nil

### 7:_G表

​	答:_G表是一个总表（table）他将我们申明的所有全局变量都储存其中，局部变量不会存储到_G表中

### 8:协程

​	答:(1)创建携程有两种方法——coroutine.create(函数)，返回值是一个thread对象/coroutine.wrap(函数)，返回值是一个函数

​	(2)启动携程有两种方法——coroutine.resume(协程对象)/wrap创建的协程可以直接调用函数来启动

​	(3)协程挂起——coroutine.yield(可以有返回值)通过create创建的协程第一个返回值默认是true或false，通过wrap创建的协程第一个返回值才是具体的返回值

### 9:元表

​	答:(1)setmetatable(table1,table2)——参数一：子表，参数二：父表

​	(2)__tostring——当尝试将一个对象转化为字符串时，如果该对象的元表有一个__tostring方法，那么这个方法会被自动调用

​	（3）__call——当尝试像函数一样调用一个对象时，__call方法会被触发，可以实现类似类和方法的调用

​	（4）__index——当尝试访问一个对象的某个属性但该对象没有时，Lua会检查该对象的元表是否有__index方法，然后访问该方法的该对象(如果有的话)

​	（5）__newindex——当尝试设置一个对象的某个属性但该对象没有时，Lua会检查该对象的元表是否有__newindex方法

### 10:垃圾回收机制

​	答:三色标记清除算法（白1，白2，灰，黑）当达到GC条件之后会从若干个根对象开始标记，如果当前对象已经被GC访问过了但是该对象的其他引用还未被标记那么会将该对象设为灰色（中间状态），如果该对象已经被GC访问过了并且该对象的其他引用也被标记过了那么会将其设为黑色（不可回收状态），标记阶段结束而清除阶段尚未开始时新创建的对象会被标记为新白色（待标记状态），在下一次GC时进行检测，清除阶段开始时会对标记为旧白色的(可回收对象)进行垃圾回收。Lua在固定间隔/内存不足/显示请求的时候会进行GC操作

### 11:Lua如何与C交互

​	答:Lua和C++是通过一个虚拟栈来交互的

C调用Lua——是由C先把数据放到栈中，再由Lua去栈中取数据，然后返回数据对应的值到栈顶，最后再由栈顶返回C。

Lua调用C——同理，先编写自己的C模块，然后注册函数到Lua解释器中，然后由Lua去调用这个模块的函数

### 12:Lua如何与C#交互

​	答:xLua和toLua封装了一个接口，可以把数据Push到虚拟栈上，然后Lua可以通过虚拟栈来访问这个对象，Lua虚拟栈也是Lua和其他语言交换数据的中介

### 13:Lua是如何实现面向对象的

​	答:Setmetatable元表+_G表+__Index的方式

### 14:table的底层实现

​	答:底层实现部分分为数组部分和哈希表部分。由三块连续内存构成——一个table结构，一块存放了连续整数索引的数组，一块大小为2的整数次幂的哈希表，并且用开放地址法解决哈希冲突

### 15:string的底层实现

​	答:底层对字符串做了分类处理，大于40字节的字符串会在堆内存中重新生成一个全新的字符串数据拷贝；小于40字节的字符串使用全局stringtable管理，相同字符串对象只会有一份数据拷贝。

### 16:xLua或toLua是如何优化跨语言调用的

答:对Lua虚拟机进行了一定程度上的封装，从而方便的使用一些接口用来调用变量等；Lua调C#时传递过来的是字符串，为了避免纯反射，封装了一个key是字符串的字典，通过这个key拿到typeofvalue避免反射提高性能。

### 17:如何实现一个只读表

​	答:只读表的本质就是要对newIndex下手，首先定义一个方法，方法里遍历这个表里是不是还有其他表的引用，是的话存到一张新表中再递归这个表。之后的主要逻辑就是对这些表进行操作。一个空子表一个元表，__index返回这个表的内容，__newIndex就报错不让外界修改。

## 资源管理面试部分

### 1:AssetBundle打包的接口叫什么

​	答:BuildPipline.BuildAssetBundles方法

### 2:AssetBundle压缩的格式和区别

​	答:不压缩（解压快，包较大）

LZMA（压缩包体小，但是解压慢，如果要使用ab包的一部分资源的话会将整个ab包都解压出来）

LZ4（压缩包体比LZMA大，但是会根据需求解压对应的资源，用什么解压什么，建议用LZ4）

### 3:打包粒度大小的权衡，打包策略，资源冗余问题

​	答:AssetBundle的数量太少会增加内存和加载时间，而太多又会导致增加下载时间和构建时间

​		资源冗余就是同一个资源被打进了多个包里，从而增加了包的大小

(1)逻辑实体分组——例如将一个UI屏幕中的所有纹理和数据打包到一起；一个角色的纹理模型和动画打包到一起；被多个场景共享的资源打包到一起

(2)类型分组——将相似或相同类型的对象放到同一个AssetBundle中，比如音频和语言文件等

(3)不相干内容分组——例如每个关卡中的对象和资源都是独一无二的，就可以把这些不相关的东西通过场景划分来打包，这样每个AssetBundle就包括了场景中的几乎所有依赖

(4)Unity官方给出过一个混合搭配的打包建议——将经常更新和很少更新的资源分开打包；合并较小但是常用的AB包；如果加载一次AB包但是我们经常连50%的资源都用不到就分开打包，以及使用依赖分析工具等

### 4:加载AssetBundle有几种方式

​	答:从内存中加载——LoadFormMemory(Async)

​		从本地文件加载——LoadFormFile(Async)

​		从服务端加载——UnityWebRequestAssetBundle或者WWW(被弃用)

### 5:从AB包中加载Asset的接口叫什么?

​	答:AssetBundle.LoadAsset

### 6:AssetBundle卸载代码，true和false的区别?

​	答:true会把AB和asset一起卸载掉，而false则只卸载ab，不会把已经load出来的asset卸载掉，也就是直接切断了asset和AB的联系

### 7:AB包中的Asset如何卸载

​	答:Resrouces.UnloadAsset——卸载指定的资源Resrouces.UnloadUnusedAsset——未被使用的Asset均会被卸载

### 8:热更新原理

​	答:通过将需要更新的资源打包成AssetBundle文件，然后上传到服务器，游戏在启动的时候可以从服务器下载最新的AssetBundle文件，并替换本地的旧资源，从而实现热更新

### 9:简单描述热更新基本流程

​	答:导出资源热更——打包热更资源的MD5信息=>上传热更ab到热更服务器=>上传版本信息到版本服务器

​		游戏热更新流程——启动游戏=>根据当前版本号和平台号去版本服务器上检查是否有热更=>从热更服务器上下载MD5码文件，比对需要热更的具体文件列表=>从热更服务器上下载需要热更的资源，解压到热更新目录

​		需要注意什么——要有下载失败重试机制、要进行超时检测、要记录更新日志，例如哪个资源导致了更新流程失败

### 10:版号管理

​	答:版号管理一般使用多段式，例如1.1.4.24第一个数字就代表主版本号，只有游戏进行重大更新时主版本号才会增加——>主版本号之后的是次版本号，在主版本内进行次要的更新或改动才会增加——>次版本号之后的是修订版本号,一般当本次版本内有数据修改或BUG修复等小改动时会增加——>最后是构建版本号，会随着每次编译或发布而更新，用于区分不同的构建版本。

### 11:整包和分包的思路和优缺点

​	答:整包——整包更新意味着每次更新时，用户需要下载整个游戏的新版本，优点是对于开发者来说方便。缺点是下载量大，对用户不便

​		分包——分包是指将游戏资源划分成多个包，每次更新时只需要替换和下载需要更新的包。优点是下载量小更新快，缺点是可能导致兼容性问题

### 12:如何解决运行时资源泄漏

​	答:使用Unload(true)——为每个对象采取引用计数管理方法，只有当AssetBundle的所有对象都没有被使用的时候再卸载AssetBundle

​		使用Unload(false)——将Asset断开与所有对象的引用，调用Resources.UnloadUnusedAsset

​		引用计数——建一个AssetBundleManager单例类，通过两个字典，一个字典通过ab名储存AssetBundle，另一个字典通过ab名储存count，在加载Ab的方法中判断字典中有没有该AB，并且检查计数字典里有没有这个AB，有的话则直接++，没有的话则添加进去并设为1。如果AB字典找不到这个AB的话则先加载AB再对这两个字典进行添加

### 13:如何检测循环依赖

​	答:一个正常的AssetBundle引用关系应该是树形结构的，即从任何一个AB出发，往上走或者往下走都会有终点，那么我们遍历所有AssetBundle，删除掉没有引用或被引用的节点，最终将一个不剩，而如果剩下，那一定这些资源存在循环依赖的关系了

## 网络开发基础面试部分

### 1:TCP或UDP服务端和客户端的代码应该怎么写？

​	答:创建套接字Socket对象——>将套接字与本地地址进行绑定——>收发消息——>释放连接——>关闭连接

### 2:客户端和服务器的交互方式有几种?

​	答:socket套接字,实现服务器和客户端之间的物理连接,并进行数据传输，主要有UDP和TCP两个协议,Socket处于网络协议的传输层

### 3:UDP和TCP的含义和区别

​	答:(1)UDP全称用户数据报协议、TCP全称数据控制协议

(2)连接性方面、可靠性方面、效率方面、连接对象数量、包头大小等

### 4:OSI七层模型有哪些?

​	答:应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。其中应用层负责应用程序之间的通信，网络编程主要针对的就是应用层；传输层则负责两台主机之间的数据传输；网络层地址管理和路由选择，路由器工作在网络层；物理层和数据链路层负责更底层的例如光信号传递和数据校验等工作

### 5:TCP建立连接的三次握手四次挥手分别是什么意思

​	答:三次握手1、客户端向服务器发送请求连接的消息2、服务器收到消息并像客户端发送确认连接的消息3、客户端收到并成功进入连接状态

​	四次挥手1、客户端向服务器发送断开连接的请求2、服务器收到消息并表示等我剩余消息发送完毕3、消息发送完毕之后向客户端发送可以断开连接的消息4、客户端说OK我会再等待一定的时间，如果期间你没有其他事情我就断开连接了

### 6:粘包、分包、封包、拆包是什么意思?

​	答:(1)粘包是指在数据传输时一条消息的尾部和下一条消息的头部拼接到了一起

(2)分包是指一条消息被拆分成了两个部分

(3)封包是指给一段数据加上包头或包尾，ID和长度

(4)拆包是指在接收端将封包的数据进行拆分

### 7:为什么会出现粘包?

答:(1)发送端需要等缓冲区满时才发送去除，造成粘包

(2)接收端没有及时接收缓冲区包数据，造成一次性接收多个包，出现粘包

### 8:如何解决粘包和分包?

​	答:粘包(1)封包:缓冲区过大造成的粘包、在发送/接收消息的时候先将消息的长度作为消息的一部分发出去，这样接收方就可以根据接收到的消息长度来动态定义缓冲区的大小，该方法也叫做自定义协议

​			(2)消息定长:如果每个消息的长度是固定的，那么接收方每次读取固定长度的数据即可，但是不够灵活



​		分包(1)消息重组:定义一个byte[]用来缓存数据，当发现分包的情况时将数据储存到这个byte[]中，然后再与下一项数据进行拼接

​			(2)消息定长

​			(3)封包信息

### 9:为什么会出现TCP拥塞控制?

​	答:拥塞的发生是因为路由器缓存溢出，拥塞会导致丢包，但丢包不一定触发拥塞。拥塞控制是4部分算法，是快速传输的基础

### 10:什么是心跳消息?

答:心跳消息是一种确认连接状态，保持连接有效性的特殊消息。在长连接中，客户端和服务器之间会定期发送心跳消息，以通知对方自己还在线。当接收方在某个特定时间内未收到心跳消息时，可能会认为发送源已经关闭。

### 11:如何实现心跳消息?

​	答:通过多线程、协程、InvokeRepeating等方法将自定义的消息转换成二进制流的方式发送给服务器

### 12:什么是网络抖动?

​	答:他主要标识一个网络的稳定性，如果最大延迟是20毫秒，最小延迟是5毫秒，那么网络抖动就是15毫秒

### 13:拓扑结构都有哪些？

​	答:星形，环形，网状形，总线型，树形，混合型

### 14:如何避免UDP出现分包的情况

​	答:控制数据包大小，在局域网尽量控制在1472个字节，互联网控制在548个字节。用Internet的标准值减去IP头部(20字节)再减去UDP头部(8字节)

### 15:为什么要三次握手四次挥手，不能是两次握手四次挥手呢？

​	答:要回答这个问题就得从三次握手中客户端和服务器之间得知了哪些信息开始说起，在第一次握手中，客户端向服务器发送了请求连接的报文段，但是客户端自己并不知道自己的消息有没有发送成功。在第二次握手中，服务器向客户端发送了报文信息，服务器可以认为我的消息已经发送成功了，那如果客户端没有经过第三次握手接收消息的话就会认为客户端和服务器之间的通信并没有建立成功，所以仅仅是两次握手是不行的，而四次握手又是没必要的，因为三次握手已经能够让客户端和服务器之间建立通信了，四次握手只会增加额外开销。

### 16:TCP为什么稳定

​	答:它提供了乱序重排，应答确认，报文重传，流量控制四种机制

(1)乱序重排——和序号有关，由于网络和多线程的因素，接收方收到的数据很可能是乱序的，不过每个TCP封装都有序号，接收方重组起来很容易

(2)应答确认——如果发送方每发送一个数据段都要等到接收方确认之后再发送下一个那么效率就太低了，所以TCP应答确认的实际原理是比如发送方的数据有1000字节，接收方收到后的确认号填写1001，那么发送方就知道接收方都收到之前的消息了，下一段消息我该从第1001个序号开始发。至于一次发多少个字节则由接收方window确认

(3)报文重传——超时重传：网速是不稳定的，传输时每个报文的延时也不一样，TCP会根据报文的往返时间自动调整超时重传时间，发送方每发一段报文都会开始计时，如果超过了超时重传时间还没有收到这个报文段的确认，就重传该报文段。比如发送方发了序号为12345的报文过去了，但是却迟迟没有收到接收方让自己发送序号为6的报文，那么超过了一定时间之后就会重新再发序号为12345的报文段

(4)报文重传——快速重传:如果接收方收到序号为1的报文段后，会回复确认号2，表示希望收到序号为2的报文段，但是却乱序收到了3或者4或者5的话，那么就会连续发出确认号2，如果发送方连续收到三次重复的确认号，就会立刻重发该条报文段，而不管是否超时。

(5)流量控制——首先要搞明白应用程序无论是发送数据还是接收数据都需要有一个缓冲区，把数据放入缓冲区然后再从缓冲区读取的这么一个过程中，如果放入的速度大于了读取的速度那么就会造成缓冲区溢出，这时就需要通过window来解决了，TCP在三次握手建立连接时，会协商双方缓冲区的window大小，然后来实时调整以避免溢出，发送方根据window来调整每次发送多少报文，就叫做滑动窗口。发送方窗口大小会根据网络带宽，时延变化和接收方的window而动态改变。

### 17:断线重连机制

​	答:当检测到客户端断线时，断开当前客户端的Socket，重新根据IP和端口号重建新的Socket，当连接上服务器网关之后，携带token向服务器发送断线重连协议，token是用于身份验证和授权的一个随机字符串，无论是初次建立连接还是断线重连都需要经过三次握手建立连接。

### 18:如何判断当前机器是大端还是小端

​	答:现在大多数个人计算机和服务器都是小端模式，只需要将一个整数转换为byte[],然后用byte[]的第0位进行比较，如果是和这个整数相等的就是小端，否则是大端

### 19:为什么客户端在四次挥手之后还会等待2MSL？

​	答:因为要确保服务端接收到了ACK报文，因为ACK在传输中很有可能丢失，如果服务器没收到确认号的话就会重新发送关闭连接请求，只有当客户端等待了2MSL都没有收到请求时才会认为服务器是收到了ACK报文的，然后就可以关闭了。

### 20:为什么是等待2个MSL

​	答:MSL是报文的最大生存时间，超过这个时间报文会被丢弃

### 21:为什么需要TIME_WAIT状态

​	答:防止接收历史报文，保证双方能够正常关闭

## 游戏优化面试部分

### 1:Unity中如何优化性能，简述一些常用的方法

#### DrawCall部分

​    (1)每次引擎准备数据并通知GPU的过程称之为一次DrawCall，DrawCall数量越高对CPU消耗就越大

​	(2)非UI方面

​			2.1.1:渲染顺序——很多人知道对UI的DrawCall优化需要打图集，以及不同图集的UI不要穿插，否则会打断合批。但其实本质就是渲染顺序被打乱了，U3D的渲染顺序是由我们控制的，控制好渲染顺序，才能控制好DrawCall

​			2.1.2:控制渲染顺序——首先在多摄像机下，U3D会根据相机的深度顺序进行渲染，另外在每个摄像机中，当物体的RenderQueue<2500时，按照SortingLayer和Orderinlayer设置的值，越小越优先，然后才是RandererQueue的值，越小越优先，如果前面这些设置都相同的话，是由物体到摄像机之间的距离，由近到远进行排序。但是当RendererQueue>2500时，设置相等时距离摄像机的位置由远到进进行排序。所以其实我们要做的就是，对要渲染的对象进行规划，按照Z轴和深度，对空间进行划分，不要让其他材质的对象打乱我们的渲染顺序，但是在3D游戏中，当人物处于复杂的场景时这种规则难免会被破坏，所以就只能在设计的时候尽量避免这种情况了

​			2.2.1:动态合批，静态合批——合批的必要条件就是相同材质的物体才能进行合批，另外合批虽然能降低DrawCall但是也会增加常驻内存，相当于在性能和内存之间做取舍

​			2.2.2:动态合批一般不需要我们经过特殊处理，Unity会对相同材质的需要合批的对象，CPU通过它们在世界空间中的顶点坐标，通过计算提交给GPU，所以我们要关注的是动态合批时付出和消耗之间的平衡点

​			2.2.3:静态合批除了材质相同之外还需要我们在inspactor面板中勾选上static属性，勾选上该属性之后物体就不能在游戏中进行移动了，它消耗内存的方式是，多个网格合并后占用的内存空间会很大

​			2.3.1:遮挡剔除远近剔除技术——在Unity的Windows窗口中有一个OcclusionCulling的选项，我们可以通过烘焙选项将所有的静态物体进行配置，但首先摄像机中要勾选剔除的属性，烘焙完成之后当静态物体脱离摄像机视口范围之后将会被Unity隐藏，这也是常用的降低DrawCall的方式之一

​			2.4.1:GPUinstancing合批——该技术可以解决静态合批中增加常驻内存的问题，它的本质就是对同一网格对象的N个实例，提交一次网格物体给GPU，GPU绘制出这个物体的N个实例到不同的位置，但缺点就是老的设备不支持该功能，而具体的实现则需要通过对shader进行操作

​			2.5.1:减少实时光和阴影——光照贴图

​	(3)UI方面

​			3.1.1:Z轴归0

​			3.1.2:打图集

​			3.1.3:UICanvas中出现的重叠和穿插现象

​			3.1.4:动静分离——有很多人在说动静分离是为了避免Canvas下的所有元素都被网格重绘，其实动静分离的Rebatch操作已经被放到子线程中了，如果画布中的元素不是那么多，盲目的动静分离的作用并没有那么大。但是对于Text和Image来说动静分离的作用很大

​			3.1.5:设置移动阈值

​			3.1.6:用RectMask2D代替Mask

​			3.1.7:取消勾选FillCenter,Unity就不需要进行额外的操作来进行中心

​			3.1.8:清理不必要的Event监听

​			3.1.9:压缩格式

​			3.1.10:由于UGUI关于优化的内容很多很杂也很细节，所以不再过多阐述，只需要记住UI的优化就是正确设置渲染顺序和尽量避免网格重绘

#### OverDraw部分

​	(1)过度绘制，每个像素被多次绘制叫做OverDraw，Overdraw影响的是GPU

​	(2)UIShader模型粒子系统地形系统镜头后处理，总之，降低OverDraw的关键就是尽可能减少绘制次数，合批绘制操作以及避免不需要的绘制

合并UI元素，使用遮罩，合并材质网格地形块，减少UI数量，OcclusionCulling，GPUinstancing，调整渲染顺序距离，LOD，模型减面

#### 其余部分

(1)场景卸载的性能开销主要取决于OnDestroy回调函数中的代码逻辑和Resources.UnloadUnusedAssets,开销主要取决于场景中Asset和Object的数量

(2)场景加载的性能开销主要在Resources.Load和AssetBundle加载的过程中

(3)Instantite实例化时，底层会先查看其相关资源是否被加载过，如果没有则加载再实例化，这是Instantite耗时问题的根本原因，所以我们可以通过预加载来缓解Instantite实例化的压力

(4)代码效率方面

### 2:Unity中如何优化内存，简述一些常用的方法

​	答:内存的开销无外乎1.资源内存占用2.引擎模块自身占用3.托管堆内存占用

(1)资源内存占用：资源主要可以分为纹理、网格、动画、音频、材质、着色器、字体资源等

1.1.1——纹理:纹理在游戏中一般会占据最大的内存开销，20482048的纹理可以达到大概16MB，因此我们要额外关注纹理

1.1.2——纹理格式:决定了内存占用和加载效率，我们要尽可能根据硬件的种类选择支持的格式，例如Android的ETC、IOS的PVRTC、PC的DXT等，至于具体的使用差别可以查看UWA的评测报告

1.1.3——纹理尺寸:一般来说纹理尺寸越大那么内存占用就越大，所以我们应该尽可能的降低纹理尺寸

1.1.4——MipMap:可以有效提升渲染效率，但是开启MipMap会将纹理内存提升大概1.33倍，3D场景可以开启但是如果UI开启的话反而会增加内存占用，因为UI本身就是在最上层渲染的

1.1.5——Read&Write:一般来说Unity是默认关闭的，但是如果开启该选项会让纹理内存增大一倍



1.2.1——网格:在游戏开发中也占据着较高的内存，对于网格资源我们可以在建模时简化模型，或者在Unity中使用内置插件减少多边形数

1.2.2——LOD:我们可以使用共享网格材质的方式来优化内存，另外我们也可以用LOD技术，这是一种类似MipMap的功能，根据距离远近来显示不同精度的模型

1.2.3——Read&Write:对于模型而言，Read&Write选项是默认开启的，如果Mesh没有被用来作为MeshCollider的基础或者不需要通过代码对其进行修改时，可以将该属性关闭，可以节省一半内存

1.2.4——MeshComperssion:Inspactor面板中的MeshComperssion是Unity对模型自动压缩的选项，可以根据情况选择，模型越Low，顶点数越小



1.3.1——动画:在不影响效果的情况下，可以减少动画的帧数

1.3.2——压缩动画精度至三位数



1.4.1——音频:使用ForcetoMono强制改成单声道

1.4.2——压缩格式:采用合理的压缩格式对音频文件进行压缩，使用MP3而不是无损的WAV



1.5.1——字体:unity使用的默认字体是微软自带的一个字体库，可能有十几MB左右，但是我们在游戏开发中并没有所有字全都用到，所以我们可以使用软件对其进行字体裁剪



(2)引擎模块自身占用:引擎自身的内存开销可以说是由巨量的”微小”内存所累积起来的，比如GameObject和Component以及各种MonoScript和Manager

​	2.1.1——优化引擎模块自身的内存占用比较麻烦，需要对Unity内部机制有一定的了解，一般我们可以通过减少不必要的模块加载，比如不需要物理模拟就禁用物理引擎，或者使用AssetBundle进行资源管理



(3)托管堆内存占用:因为在Unity中，Mono的堆内存一旦被分配就不会返还给系统，这意味着Mono的堆内存是只升不降的，所以我们可以针对代码进行一系列的内存优化

​	3.1.1——避免在Update或FixedUpdate这种高调用频率的函数中开辟内存

​	3.1.2——打包之前删除所有的Log日志输出

​	3.1.3——使用对象池

​	3.1.4——及时删除不再使用的对象

​	3.1.5——优化字符串的使用

​	3.1.6——优化数据结构

​	3.1.7——合理使用引用类型和值类型

​	3.1.8——熟悉Profiler的使用

​	3.1.9——AssetBundle避免资源冗余

​	3.1.10——打包时将配置表文件压缩在一个二进制文件内

## 项目面试部分

### RTS——兵种选择以及阵型功能

​	答:LineRenderer，射线检测，向量，范围碰撞器

### RTS——兵种及建筑制造功能

​	答:单例模式+状态模式+工厂模式+观察者模式+对象池+协程递归。分为工厂部分，UI部分，和实体部分。基于工厂模式的设计思想，我创建了一个FactoryManager单例类，用来管理游戏中所有对象的创建，方法通过传入对象的枚举类型从对象池中取出或创建并返回这个GameObject的对应对象。外部UI只需要调用FactoryManager的方法就可以生成建筑或士兵，从而不需要关心具体的实现细节。在UI方面呢，由于我想完全复刻红警的这个冷却系统，所以使用了协程递归的方法，并由Button监听该事件，完成该效果。在每次转完一圈之后会通知监听者士兵工厂生成对应类型士兵，最后士兵工厂通过射线射击工厂前方随机范围空地的功能，解决了士兵扎堆生成的问题;

### RTS——士兵/建筑战斗功能

​	答:分两个部分，一个是实际战斗需要做哪些事情，另一个战斗的检测部分，是因为在项目设计之初，所有的士兵Animator模型都是一样的，而且种类没那么多，所以战斗部分没有用到有限状态机，而是通过switchcase的方式，通过一个脚本对所有种类的士兵进行战斗检测。实际的战斗是根据不同兵种做的不同表现，例如人类士兵是用枪的，那么我就用点乘叉乘代替了射线检测，为了性能考虑。第二个是近战士兵，我用了动画事件的方式，第三种是法师弓箭手和飞龙类士兵，因为本身攻击有延迟，所以生成了实际的攻击碰撞体。另外在战斗的检测部分，有一个比较巧妙的设计，因为士兵实际上需要三个不同碰撞体……

### 寻路部分:

​		不同兵种的战斗设计部分:项目在设计之初所有的士兵Animator模型都是一样的，只提供了站立，移动，攻击，死亡，胜利的动作，所以基于有限状态机做起来基本只需要复制粘贴改改类名就能完成，剩下的工作就只剩下了每个状态中update需要做的事情。

## 图形学面试部分

### (1)渲染管线

#### 1.1渲染管线是什么

总结:渲染管线的概念是将数据分阶段的变为屏幕图像的过程

（1）数据指的是1.顶点数据（模型的顶点坐标，法线向量，纹理坐标等）2.纹理数据（纹理贴图等）3.光照数据（光照参数，光源信息等）

（2）阶段分三个，应用阶段——>几何阶段——>光栅化阶段，每一个阶段都会对数据进行处理，最终目的就是让我们看见最终的图像

#### 1.2应用阶段

​	总结:渲染管线应用阶段中大部分内容都和渲染无关，应用阶段为渲染管线的后续提供了最重要的内容——数据，应用阶段的主导者是CPU，在这一阶段，我们将渲染需要用到的数据传递给GPU用于后续的两个阶段的处理

​	顺序:把不可见的物体数据剔除——>准备好模型相关数据——>将数据加载到显存中——>设置渲染状态——>调用DrawCall(CPU通知GPU使用相关的数据和渲染状态进行渲染)

​	DrawCall:使用批处理技术可以有效减少DrawCall，1.合并网格2.共用材质3.合并图集

#### 1.3几何阶段

​	图元:几何数据的基本单元，可以是点，线，三角形。在几何阶段，顶点数据会被组合为图元，图元将在光栅化阶段转换为像素，最终呈现在屏幕上

​	顶点着色器:1.坐标转换——顶点、法线、纹理坐标变换2.顶点属性处理——顶点颜色、透明度、切线向量等3.顶点插值——计算顶点属性的插值值，对我们来说，顶点着色器是完全可编程的

​	总结:几何阶段的主要工作是对顶点进行处理，并进行坐标转换，裁剪画面外的图元。最主要完成的就是将模型的顶点从其本地坐标转换到最终的屏幕坐标中

#### 1.4光栅化阶段

​	片元:光栅化阶段生成的像素或像素片段，每个片元代表了屏幕上的一个像素，以及其颜色，深度值，法线等等信息

​	片元着色器:需要完成的主要工作有1.光照计算2.纹理映射3.材质属性处理4.阴影计算。对我们来说片元着色器是完全可编程的

​	总结:光栅化阶段的主要工作是对片元进行最终的处理，确认片元最终是否被渲染到屏幕上，并确认其最终渲染的颜色效果

#### 1.5图形接口程序

总结:OpenGL(跨平台，几乎所有平台可以使用)DX（针对微软的Windows平台）WebGL（网页相关）图形接口程序为shader开发提供了各种API，不同的图形接口程序对Shader开发的影响主要是开发语言不同，坐标原点不同

### (2)线性代数

#### 2.1矩阵乘法

​	总结:（1）矩阵和标量相乘——直接让矩阵(M)中的每一个标量和标量(K)相乘即可

​		（2）矩阵和矩阵相乘——判断条件:左边矩阵的行数要和右边矩阵的列数相等结果矩阵结构:左行右列标量相乘规则:左行乘以右列再相加

​		（3）不满足交换律，满足结合律

#### 2.2特殊矩阵

​	总结:（1）方块矩阵——行列数相等的矩阵

​		（2）对角矩阵——只有主对角线（左上到右下）有值，其余元素全为0的方阵

​		（3）单位矩阵——主对角线上的元素均为1的对角矩阵

​		（4）数量矩阵——主对角线上的元素为同一值的对角矩阵

​		（5）转置矩阵——将原始矩阵的行和列互换得到的新矩阵;矩阵转置的转置等于原矩阵;矩阵串接的转置等于翻转串接各个矩阵的转置